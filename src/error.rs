/// The Error returned by scanf!() if matching or parsing failed.
pub enum Error<'input> {
    /// The Regex generated by scanf did not match the input string.
    ///
    /// Provides the input string and the generated Regex for debugging purposes.
    RegexMatchFailed(&'input str, &'static regex::Regex),
    /// The Regex matched, but any of the [`FromStr`](std::str::FromStr) implementations of the
    /// return types failed.
    ///
    /// Provides the name of the type, the string that was given to
    /// [`FromStr`](std::str::FromStr) and the error that it returned.
    ///
    /// This case can indicate that the [`RegexRepresentation`](crate::RegexRepresentation) might
    /// be too lax or that the [`FromStr`](std::str::FromStr) implementation is incorrect.
    FromStrFailed(&'static str, &'input str, Box<dyn std::fmt::Debug>),
}

impl std::error::Error for Error<'_> {}

impl<'input> std::fmt::Debug for Error<'input> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::RegexMatchFailed(input, regex) => {
                write!(f, "RegexMatchFailed({:?}, {:?})", input, regex)
            }
            Error::FromStrFailed(ty, input, error) => {
                write!(
                    f,
                    "FromStrFailed(type: {}, input: {:?}, error: {:?})",
                    ty, input, error
                )
            }
        }
    }
}

impl<'input> std::fmt::Display for Error<'input> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::RegexMatchFailed(input, regex) => {
                write!(
                    f,
                    "scanf: Failed to match string {:?} against regex {}",
                    input, regex
                )
            }
            Error::FromStrFailed(ty, input, error) => {
                write!(
                    f,
                    "scanf: Could not convert type <{}> from input \"{}\": {:?}",
                    ty, input, error
                )
            }
        }
    }
}

impl<'input> PartialEq for Error<'input> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Error::RegexMatchFailed(input1, regex1), Error::RegexMatchFailed(input2, regex2)) => {
                input1 == input2 && regex1.as_str() == regex2.as_str()
            }
            (
                Error::FromStrFailed(ty1, input1, error1),
                Error::FromStrFailed(ty2, input2, error2),
            ) => {
                ty1 == ty2 && input1 == input2 && format!("{:?}", error1) == format!("{:?}", error2)
            }
            _ => false,
        }
    }
}
