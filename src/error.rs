/// The Error returned by scanf!() if matching or parsing failed.
///
/// Note that this type has a lifetime parameter, which is the lifetime of the input string.
/// This is necessary to print the relevant part of the input string in the error message,
/// without having to clone it. This is done because the main use cases for this crate will either
/// assume that the matching always works and thus use `unwrap` or similar, or assume that it
/// might fail and thus filter any failing cases. Since the filtering case does not care about
/// the error, it would be a waste to allocate and clone data that will be thrown away.
///
/// **TL;DR**: The Result returned by scanf _should_ be treated like an `Option`!
///
/// The Error is only relevant when there is a bug in
/// - The format string
/// - A custom Regex implementation
/// - A custom FromStr implementation.
///
/// These are the main cases where the `Error` is relevant.
///
/// If any of those are a risk, use `unwrap()` to print the Error directly or print it yourself
/// in a `match` or similar. DO NOT use the `?`-operator! `?` will not compile because of the
/// lifetime parameter. (If you absolutely have to use `?`, turn the Error into an owned value
/// by calling `.map_err(|err| err.to_string())?` first.)
#[derive(Debug)]
pub enum Error<'input> {
    /// The Regex generated by scanf did not match the input string.
    ///
    /// # Example
    /// ```
    /// # use sscanf::*;
    /// let result = scanf!("text", "a{}", String);
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    ///
    /// assert_eq!(err.to_string(), r#"scanf: Failed to match string "text" against regex ^a(.+?)$"#);
    /// assert_eq!(format!("{:?}", err), r#"RegexMatchFailed { input: "text", regex: ^a(.+?)$ }"#);
    ///
    /// if let Error::RegexMatchFailed { input, regex } = err {
    ///     assert_eq!(input, "text");
    ///     assert_eq!(regex.as_str(), r"^a(.+?)$");
    /// } else {
    ///     panic!("Unexpected error: {:?}", err);
    /// }
    /// ```
    RegexMatchFailed {
        /// The entire input string that was provided to scanf
        input: &'input str,
        /// The Regex generated by scanf
        regex: &'static regex::Regex,
    },
    /// The Regex matched, but any of the [`FromStr`](std::str::FromStr) implementations of the
    /// return types failed.
    ///
    /// This case can indicate that the [`RegexRepresentation`](crate::RegexRepresentation) might
    /// be too lax or that the [`FromStr`](std::str::FromStr) implementation is incorrect.
    ///
    /// # Example
    /// ```
    /// # use sscanf::*;
    /// let input = "5 word 2";
    /// let result = scanf!(input, "{usize} {u32:/.*/} {u8}"); // force u32 to accept "word"
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    ///
    /// assert_eq!(err.to_string(), r#"scanf: Could not convert type <u32> from input "word": ParseIntError { kind: InvalidDigit }"#);
    /// assert_eq!(format!("{:?}", err), r#"FromStrFailed { type_name: "u32", input: "word", error: ParseIntError { kind: InvalidDigit } }"#);
    ///
    /// if let sscanf::Error::FromStrFailed { type_name, input, error } = err {
    ///     assert_eq!(type_name, "u32");
    ///     assert_eq!(input, "word");
    ///     assert_eq!(
    ///         format!("{:?}", error),
    ///         "ParseIntError { kind: InvalidDigit }"
    ///     );
    /// } else {
    ///     panic!("Unexpected error type");
    /// }
    /// ```
    FromStrFailed {
        /// The name of the type that failed to parse
        type_name: &'static str,
        /// The part of the input string that was given to [`FromStr`](std::str::FromStr)
        input: &'input str,
        /// The error that [`FromStr`](std::str::FromStr) returned.
        ///
        /// Since [`FromStr::Err`](https://doc.rust-lang.org/std/str/trait.FromStr.html#associatedtype.Err)
        /// has no requirements for what kind of error can be returned, this just hopes that it
        /// implements Debug.
        error: Box<dyn std::fmt::Debug>,
    },
}

impl std::error::Error for Error<'_> {}

impl<'input> std::fmt::Display for Error<'input> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::RegexMatchFailed { input, regex } => {
                write!(
                    f,
                    "scanf: Failed to match string {:?} against regex {}",
                    input, regex
                )
            }
            Error::FromStrFailed {
                type_name,
                input,
                error,
            } => {
                write!(
                    f,
                    "scanf: Could not convert type <{}> from input \"{}\": {:?}",
                    type_name, input, error
                )
            }
        }
    }
}

impl<'input> PartialEq for Error<'input> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                Error::RegexMatchFailed { input, regex },
                Error::RegexMatchFailed {
                    input: input2,
                    regex: regex2,
                },
            ) => input == input2 && regex.as_str() == regex2.as_str(),
            (
                Error::FromStrFailed {
                    type_name,
                    input,
                    error,
                },
                Error::FromStrFailed {
                    type_name: type_name2,
                    input: input2,
                    error: error2,
                },
            ) => {
                type_name == type_name2
                    && input == input2
                    && format!("{:?}", error) == format!("{:?}", error2)
            }
            _ => false,
        }
    }
}
