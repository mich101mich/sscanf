/// The Error returned by scanf!() if matching or parsing failed.
#[derive(Debug)]
pub enum Error<'input> {
    /// The Regex generated by scanf did not match the input string.
    ///
    /// # Example
    /// ```
    /// # use sscanf::*;
    /// let result = scanf!("text", "a{}", String);
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    ///
    /// assert_eq!(err.to_string(), r#"scanf: Failed to match string "text" against regex ^a(?P<type_1>.+?)$"#);
    /// assert_eq!(format!("{:?}", err), r#"RegexMatchFailed { input: "text", regex: ^a(?P<type_1>.+?)$ }"#);
    ///
    /// if let Error::RegexMatchFailed { input, regex } = err {
    ///     assert_eq!(input, "text");
    ///     assert_eq!(regex.as_str(), r"^a(?P<type_1>.+?)$");
    ///     //             actual regex: ^a.+?$
    ///     // the ?P<type_1> part is a named capture group which allows scanf to access the
    ///     // matched content under the name "type_1" for parsing. See scanf_get_regex!()
    /// } else {
    ///     panic!("Unexpected error: {:?}", err);
    /// }
    /// ```
    RegexMatchFailed {
        /// The entire input string that was provided to scanf
        input: &'input str,
        /// The Regex generated by scanf
        regex: &'static regex::Regex,
    },
    /// The Regex matched, but any of the [`FromStr`](std::str::FromStr) implementations of the
    /// return types failed.
    ///
    /// This case can indicate that the [`RegexRepresentation`](crate::RegexRepresentation) might
    /// be too lax or that the [`FromStr`](std::str::FromStr) implementation is incorrect.
    ///
    /// # Example
    /// ```
    /// # use sscanf::*;
    /// let input = "5 word 2";
    /// let result = scanf!(input, "{usize} {u32:/.*/} {u8}"); // force u32 to accept "word"
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    ///
    /// assert_eq!(err.to_string(), r#"scanf: Could not convert type <u32> from input "word": ParseIntError { kind: InvalidDigit }"#);
    /// assert_eq!(format!("{:?}", err), r#"FromStrFailed { type_name: "u32", input: "word", error: ParseIntError { kind: InvalidDigit } }"#);
    ///
    /// if let sscanf::Error::FromStrFailed { type_name, input, error } = err {
    ///     assert_eq!(type_name, "u32");
    ///     assert_eq!(input, "word");
    ///     assert_eq!(
    ///         format!("{:?}", error),
    ///         "ParseIntError { kind: InvalidDigit }"
    ///     );
    /// } else {
    ///     panic!("Unexpected error type");
    /// }
    /// ```
    FromStrFailed {
        /// The name of the type that failed to parse
        type_name: &'static str,
        /// The part of the input string that was given to [`FromStr`](std::str::FromStr)
        input: &'input str,
        /// The error that [`FromStr`](std::str::FromStr) returned.
        ///
        /// Since [`FromStr::Err`](https://doc.rust-lang.org/std/str/trait.FromStr.html#associatedtype.Err)
        /// has no requirements for what kind of error can be returned, this just hopes that it
        /// implements Debug.
        error: Box<dyn std::fmt::Debug>,
    },
}

impl std::error::Error for Error<'_> {}

impl<'input> std::fmt::Display for Error<'input> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::RegexMatchFailed { input, regex } => {
                write!(
                    f,
                    "scanf: Failed to match string {:?} against regex {}",
                    input, regex
                )
            }
            Error::FromStrFailed {
                type_name,
                input,
                error,
            } => {
                write!(
                    f,
                    "scanf: Could not convert type <{}> from input \"{}\": {:?}",
                    type_name, input, error
                )
            }
        }
    }
}

impl<'input> PartialEq for Error<'input> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                Error::RegexMatchFailed { input, regex },
                Error::RegexMatchFailed {
                    input: input2,
                    regex: regex2,
                },
            ) => input == input2 && regex.as_str() == regex2.as_str(),
            (
                Error::FromStrFailed {
                    type_name,
                    input,
                    error,
                },
                Error::FromStrFailed {
                    type_name: type_name2,
                    input: input2,
                    error: error2,
                },
            ) => {
                type_name == type_name2
                    && input == input2
                    && format!("{:?}", error) == format!("{:?}", error2)
            }
            _ => false,
        }
    }
}
