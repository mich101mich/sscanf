#![deny(
    missing_docs,
    missing_debug_implementations,
    missing_copy_implementations,
    trivial_casts,
    trivial_numeric_casts,
    unsafe_code,
    unstable_features,
    unused_import_braces,
    unused_qualifications,
    rustdoc::missing_doc_code_examples,
    rustdoc::broken_intra_doc_links,
    rustdoc::private_intra_doc_links,
    rustdoc::missing_crate_level_docs,
    rustdoc::invalid_codeblock_attributes,
    rustdoc::bare_urls
)]
// TODO: Update format options
// TODO: Talk about regex escaping (JavaScript)
// TODO: Remove chrono
// TODO: Remove error
// TODO: from_scanf docs
// TODO: derive: add docs, add tests, Generics
// TODO: fail tests for type index, format options, derive
// TODO: Add more format options

//! A sscanf (inverse of format!()) Macro based on Regex
//!
//! # sscanf
//! `sscanf` is originally a C-function that takes a string, a format string with placeholders and
//! several variables (in the Rust version replaced with types). It then parses the input string,
//! writing the values behind the placeholders into the variables (Rust: returns a tuple). `sscanf`
//! can be thought of as reversing a call to `format!()`:
//! ```
//! # use sscanf::scanf;
//! // format: takes format string and values, returns String
//! let msg = format!("Hello {}{}!", "World", 5);
//! assert_eq!(msg, "Hello World5!");
//!
//! // scanf: takes string, format string and types, returns tuple
//! let parsed = scanf!(msg, "Hello {}{}!", str, usize);
//!
//! // parsed is Result<(&str, usize), ...>
//! assert_eq!(parsed.unwrap(), ("World", 5));
//!
//! // alternative syntax:
//! let parsed2 = scanf!(msg, "Hello {str}{usize}!");
//! assert_eq!(parsed2.unwrap(), ("World", 5));
//! ```
//! `scanf!()` takes a format string like `format!()`, but doesn't write
//! the values into the placeholders (`{}`), but extracts the values at those `{}` into the return
//! tuple.
//!
//! If matching the format string failed, an Error is returned:
//! ```
//! # use sscanf::scanf;
//! let msg = "Text that doesn't match the format string";
//! let parsed = scanf!(msg, "Hello {str}{usize}!");
//! assert!(matches!(parsed, Err(sscanf::Error::MatchFailed)));
//! ```
//!
//! Note that the original C-function and this Crate are called sscanf, which is the technically
//! correct version in this context. `scanf` (with one `s`) is a similar C-function that reads a
//! console input instead of taking a string parameter. The macro itself is called `scanf!()`
//! because that is shorter, can be pronounced without sounding too weird and nobody uses the stdin
//! version anyway.
//!
//! **Types in Placeholders:**
//!
//! The types can either be given as a separate parameter after the format string, or directly
//! inside of the `{}` placeholder.  
//! The first allows for autocomplete while typing, syntax highlighting and better compiler errors
//! generated by scanf in case that the wrong types are given.  
//! The second imitates the [Rust format!() behavior since 1.58](https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html#captured-identifiers-in-format-strings).
//! This option gives [worse compiler errors](#a-note-on-compiler-errors) when using stable Rust,
//! but is otherwise identical to the first option.
//!
//! More examples of the capabilities of [`scanf`]:
//! ```
//! # use sscanf::scanf;
//! let input = "<x=3, y=-6, z=6>";
//! let parsed = scanf!(input, "<x={i32}, y={i32}, z={i32}>");
//! assert_eq!(parsed.unwrap(), (3, -6, 6));
//!
//! let input = "Move to N36E21";
//! let parsed = scanf!(input, "Move to {char}{usize}{char}{usize}");
//! assert_eq!(parsed.unwrap(), ('N', 36, 'E', 21));
//!
//! let input = "Escape literal { } as {{ and }}";
//! let parsed = scanf!(input, "Escape literal {{ }} as {{{{ and }}}}");
//! assert_eq!(parsed.unwrap(), ());
//!
//! let input = "Indexing types: N36E21";
//! # use std::num::NonZeroUsize;
//! let parsed = scanf!(input, "Indexing types: {1}{0}{1}{0}", NonZeroUsize, char);
//! // output is in the order of the placeholders
//! assert_eq!(parsed.unwrap(), ('N', NonZeroUsize::new(36).unwrap(),
//!                              'E', NonZeroUsize::new(21).unwrap()));
//!
//! let input = "A Sentence with Spaces. Another Sentence.";
//! // str and String do the same, but String clones from the input string
//! // to take ownership instead of borrowing.
//! let (a, b) = scanf!(input, "{String}. {String}.").unwrap();
//! assert_eq!(a, "A Sentence with Spaces");
//! assert_eq!(b, "Another Sentence");
//!
//! // Number format options
//! let input = "ab01  127  101010  1Z";
//! let parsed = scanf!(input, "{usize:x}  {i32:o}  {u8:b}  {u32:r36}");
//! let (a, b, c, d) = parsed.unwrap();
//! assert_eq!(a, 0xab01);     // Hexadecimal
//! assert_eq!(b, 0o127);      // Octal
//! assert_eq!(c, 0b101010);   // Binary
//!
//! assert_eq!(d, 71);         // any radix (r36 = Radix 36)
//! assert_eq!(d, u32::from_str_radix("1Z", 36).unwrap());
//!
//! let input = "color: #D4AF37";
//! // Number types take their size into account, and hexadecimal u8 can
//! // have at most 2 digits => only possible match is 2 digits each.
//! let (r, g, b) = scanf!(input, "color: #{u8:x}{u8:x}{u8:x}").unwrap();
//! assert_eq!((r, g, b), (0xD4, 0xAF, 0x37));
//! ```
//! The input in this case is a `&'static str`, but it can be `String`, `&str`, `&String`, ...
//! Basically anything with [`Deref<Target=str>`](https://doc.rust-lang.org/std/ops/trait.Deref.html).
//! and without taking ownership.
//!
//! The parsing part of this macro has very few limitations, since it replaces the `{}` with a
//! Regular Expression ([`regex`](https://docs.rs/regex)) that corresponds to that type.
//! For example:
//! - `char` is just one character (regex `"."`)
//! - `str` is any sequence of characters (regex `".+?"`)
//! - Numbers are any sequence of digits (regex `"[-+]?\d+"`)
//!
//! And so on. The actual implementation for numbers tries to take the size of the type into
//! account and some other details, but that is the gist of the parsing.
//!
//! This means that any sequence of replacements is possible as long as the Regex finds a
//! combination that works. In the `char, usize, char, usize` example above it manages to assign
//! the `N` and `E` to the `char`s because they cannot be matched by the `usize`s.
//!
//! # Format Options
//! All options are inside `'{'` `'}'` and after a `:`, so either as `{<type>:<option>}` or
//! as `{:<option>}`. Note: The type might still have a path that contains `::`. Any double
//! colons are ignored and only single colons are used to separate the options.
//!
//! Procedural macro don't have any reliable type info and can only compare types by name. This means
//! that the number options below only work with a literal type like "`i32`", **NO** Paths (~~`std::i32`~~)
//! or Wrappers (~~`struct Wrapper(i32);`~~) or Aliases (~~`type Alias = i32;`~~). **ONLY** `i32`,
//! `usize`, `u16`, ...
//!
//! | config                      | description                | possible types |
//! | --------------------------- | -------------------------- | -------------- |
//! | `{:/` _\<regex>_ `/}`       | custom regex               | any            |
//! | `{:x}`                      | hexadecimal numbers        | integers       |
//! | `{:o}`                      | octal numbers              | integers       |
//! | `{:b}`                      | binary numbers             | integers       |
//! | `{:r2}` - `{:r36}`          | radix 2 - radix 36 numbers | integers       |
//! | `#`                         | ["alternate" form](https://doc.rust-lang.org/std/fmt/index.html#sign0) | all numbers    |
//!
//! **Custom Regex:**
//!
//! - `{:/.../}`: Match according to the [`Regex`](https://docs.rs/regex) between the `/` `/`
//!
//! For example:
//! ```
//! # use sscanf::scanf;
//! let input = "random Text";
//! let parsed = scanf!(input, "{str:/[^m]+/}{str}");
//!
//! // regex  [^m]+  matches anything that isn't an 'm'
//! // => stops at the 'm' in 'random'
//! assert_eq!(parsed.unwrap(), ("rando", "m Text"));
//! ```
//!
//! The regex uses the [`same escaping logic as JavaScripts /.../ syntax`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping)
//! with the addition that rust strings require escaping of `\` with `\\`. To avoid double
//! backslashes, you can use raw strings:
//! ```
//! # use sscanf::scanf;
//! let input = "1234";
//! let parsed = scanf!(input, r"{u8:/\d/}{u8}"); // regex  \d  only matches 1 digit
//! let _ =      scanf!(input, "{u8:/\\d/}{u8}"); // the same with a non-raw string
//! assert_eq!(parsed.unwrap(), (1, 234));
//! ```
//!
//! Note: If you use any unescaped ( ) in your regex, you have to prevent them from forming
//! a capture group by adding a `?:` at the beginning: `{:/..(..)../}` becomes `{:/..(?:..)../}`.
//!
//! **Radix Options:**
//!
//! Only work on primitive integer types (`u8`, ..., `u128`, `i8`, ..., `i128`, `usize`, `isize`).
//! - `x`: hexadecimal Number (Digits 0-9 and a-f or A-F)
//! - `o`: octal Number (Digits 0-7)
//! - `b`: binary Number (Digits 0-1)
//! - `r2` - `r36`: any radix Number (Digits 0-9 and a-z or A-Z for higher radices)
//!
//! **alternate form:**
//!
//! If used alongside a radix option: makes the number require a prefix (0x, 0o, 0b).
//!
//! If used on `f32` or `f64`: matches the full range of floating point identifiers like `nan`, `inf`, `2.0e5`, ...
//!
//! Normal `f32` and `f64` only accept numbers with an optional sign and decimal point. This is
//! done to avoid accidentally matching against text:
//! ```
//! # use sscanf::*;
//! let input = "Match a Banana against a number";
//! let output = scanf!(input, "{str}{f32}{str}");
//! // There are no Numbers in input, so expect no match
//! assert!(output.is_err());
//!
//! // let output = scanf!(input, "{str}{f32:#}{str}"); // TODO:
//! // // The 'nan' part in "Banana" is parsed as f32::NaN
//! // assert!(output.unwrap().1.is_nan());
//! ```
//!
//! # Custom Types
//!
//! [`scanf`] works with most primitive Types from `std` as well as `String` by default. The
//! full list can be seen here: [Implementations of `RegexRepresentation`](./trait.RegexRepresentation.html#foreign-impls).
//!
//! To add more types there are three options:
//! - Derive [`FromScanf`] for your type (recommended)
//! - Implement **both** [`RegexRepresentation`] and [`std::str::FromStr`] for your type
//! - Implement [`RegexRepresentation`] and manually implement [`FromScanf`] for your type (highly discouraged)
//!
//! ```
//! use sscanf::{scanf, FromScanf};
//! # #[derive(Debug, PartialEq)]
//! #[derive(FromScanf)]
//! #[scanf(format = "#{r:x}{g:x}{b:x}")] // matches '#' followed by 3 hexadecimal u8s
//! struct Color {
//!     r: u8,
//!     g: u8,
//!     b: u8,
//! }
//!
//! let input = "color: #ff00cc";
//! let parsed = scanf!(input, "color: {Color}");
//! assert_eq!(parsed.unwrap(), Color { r: 0xff, g: 0x00, b: 0xcc });
//! ```
//!
//! A manual implementation of [`RegexRepresentation`] and [`FromStr`] for `Color` would look like this:
//! ```
//! use sscanf::{scanf, RegexRepresentation};
//! use std::str::FromStr;
//! # #[derive(Debug, PartialEq)]
//! struct Color {
//!    r: u8,
//!    g: u8,
//!    b: u8,
//! }
//! impl RegexRepresentation for Color {
//!     // matches '#' followed by 6 hexadecimal digits
//!     const REGEX: &'static str = r"#[0-9a-fA-F]{6}";
//! }
//! #[derive(Debug)]
//! enum ColorParseError {
//!     InvalidHexDigit(std::num::ParseIntError),
//!     InvalidLength,
//!     InvalidPrefix,
//! }
//! impl std::error::Error for ColorParseError {}
//! impl std::fmt::Display for ColorParseError {
//!     // ...
//! #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "Invalid Color") }
//! }
//! impl From<std::num::ParseIntError> for ColorParseError {
//!     // ...
//! #     fn from(err: std::num::ParseIntError) -> Self {
//! #         ColorParseError::InvalidHexDigit(err)
//! #     }
//! }
//! impl FromStr for Color {
//!     type Err = ColorParseError;
//!     fn from_str(s: &str) -> Result<Self, Self::Err> {
//!         if !s.starts_with('#') {
//!             return Err(ColorParseError::InvalidPrefix);
//!         }
//!         if s.len() != 7 {
//!             return Err(ColorParseError::InvalidLength);
//!         }
//!         let r = u8::from_str_radix(&s[1..3], 16)?;
//!         let g = u8::from_str_radix(&s[3..5], 16)?;
//!         let b = u8::from_str_radix(&s[5..7], 16)?;
//!         Ok(Color { r, g, b })
//!     }
//! }
//! let input = "color: #ff00cc";
//! let parsed = scanf!(input, "color: {Color}");
//! assert_eq!(parsed.unwrap(), Color { r: 0xff, g: 0x00, b: 0xcc });
//! ```
//! This option gives a lot more control over the parsing process, but requires more code and
//! manual error handling. This may also be slower at runtime since the [`FromScanf`] implementation
//! has direct access to the initial parsing result instead of having to parse the string again
//! in the [`FromStr`] implementation.
//!
//! A custom implementation of [`FromScanf`] requires some in-depth knowledge and is thus not
//! recommended and not described here. See the trait documentation for more information.
//!
//! Implementing `RegexRepresentation` isn't strictly necessary if you **always** supply a custom
//! Regex when using the type by using the `{:/.../}` format option, but this tends to make your code
//! less readable.
//!
//! # A Note on Compiler Errors
//!
//! Errors in the format string would ideally point to the exact position in the string that
//! caused the error. This is already the case if you compile/check with nightly, but not on
//! stable, or at least until Rust Issue [`#54725`](https://github.com/rust-lang/rust/issues/54725)
//! is far enough to allow for [`this method`](https://doc.rust-lang.org/proc_macro/struct.Literal.html#method.subspan)
//! to be called from stable.
//!
//! Compiler Errors on nightly currently look like this:
//! ```compile_fail
//! # use sscanf::scanf;
//! scanf!("", "Too many placeholders: {}{}{}", usize);
//! ```
//! ```text
//! error: more placeholders than types provided
//!   |
//! 4 | scanf!("", "Too many placeholders: {}{}{}", usize);
//!   |                                      ^^
//! ```
//! But on stable, you are limited to only pointing at the entire format string:
//! ```text
//! 4 | scanf!("", "Too many placeholders: {}{}{}", usize);
//!   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//! ```
//! The current workaround is to replicate that behavior in the error message
//! itself:
//! ```text
//! error: more placeholders than types provided:
//!        At "Too many placeholders: {}{}{}"
//!                                     ^^
//!   |
//! 4 | scanf!("", "Too many placeholders: {}{}{}", usize);
//!   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//! ```
//!
//! The alternative is to use `cargo +nightly check` to see the better errors
//! whenever something goes wrong, or setting your Editor plugin to check with nightly.
//!
//! This does _**not**_ influence the functionality in any way. This Crate works entirely on stable
//! with no drawbacks in functionality or performance. The only difference is the compiler errors
//! that you get while writing format strings.

/// A Macro to parse a string based on a format-string, similar to sscanf in C
///
/// ## Signature
/// ```ignore
/// scanf!(input: impl Deref<Target=str>, format: <literal>, Type...) -> Result<(Type...), sscanf::Error>
/// ```
///
/// ## Parameters
/// * `input`: The string to parse. Can be anything that implements [`Deref<Target=str>`](std::ops::Deref)
///   (e.g. `&str`, `String`, `Cow<str>`, etc. See examples below). Note that `scanf` does not take
///   ownership of the input.
/// * `format`: A literal string. No const or static allowed, just like with [`format!()`](std::format).
/// * `Type...`: The types to parse. See [Custom Types](index.html#custom-types) for more information.
///
/// ## Return Value
/// A [`Result`](std::result::Result) with a tuple of the parsed types or a [`sscanf::Error`](crate::Error).
/// Note that an error usually indicates that the input didn't match the format string, making the
/// returned [`Result`](std::result::Result) functionally equivalent to an [`Option`](std::option::Option),
/// and most applications should treat it that way. An error is only useful when debugging
/// custom implementations of [`FromStr`](std::str::FromStr) or [`FromScanf`](crate::FromScanf).
/// See [`sscanf::Error`](crate::Error) for more information.
///
/// ## Details
/// The format string _has_ to be a string literal (with some form of `"` on either side),
/// because it is parsed by the procedural macro at compile time and checks if all the types
/// and placeholders are matched. This is not possible from inside a variable or even a `const
/// &str` somewhere else.
///
/// Placeholders within the format string are marked with `{}`. Any `'{'` or `'}'` that should not be
/// treated as placeholders need to be escaped by writing `'{{'` or `'}}'`. For every placeholder there
/// has to be a type name inside the `{}` or exactly one type in the parameters after the format
/// string. Types can be referenced by indices in the placeholder, similar to [`format!()`](std::fmt).
///
/// Any additional formatting options are placed behind a `:`. For a list of options, see
/// the [crate root documentation](index.html#format-options).
///
/// ## Examples
/// A few examples for possible inputs:
/// ```
/// # use sscanf::scanf;
/// let input = "5"; // &str
/// assert_eq!(scanf!(input, "{usize}").unwrap(), 5);
///
/// let input = String::from("5"); // String
/// assert_eq!(scanf!(input, "{usize}").unwrap(), 5);
///
/// // does not work because it creates a temporary value
/// // assert_eq!(scanf!(String::from("5"), "{usize}").unwrap(), 5);
///
/// let input = &input; // &String
/// assert_eq!(scanf!(input, "{usize}").unwrap(), 5);
/// assert_eq!(scanf!(input.as_str(), "{usize}").unwrap(), 5);
///
/// let input = std::borrow::Cow::from("5"); // Cow<str>
/// assert_eq!(scanf!(input, "{usize}").unwrap(), 5);
///
/// let input = std::rc::Rc::from("5"); // Rc<str>
/// assert_eq!(scanf!(input, "{usize}").unwrap(), 5);
///
/// // and many more
/// ```
///
/// More Examples can be seen in the crate root documentation.
pub use sscanf_macro::scanf;

/// Same as [`scanf`], but returns the regex without running it. Useful for debugging or efficiency.
///
/// ## Signature
/// ```ignore
/// scanf_get_regex!(format: <literal>, Type...) -> &'static Regex
/// ```
///
/// ## Parameters
/// * `format`: A literal string. No const or static allowed, just like with [`format!()`](std::format).
/// * `Type...`: The types to parse. See [Custom Types](index.html#custom-types) for more information.
///
/// Returns: A reference to the generated [`Regex`](regex::Regex).
///
/// The Placeholders can be obtained by capturing the Regex and using the 1-based index of the Group.
///
/// ## Examples
/// ```
/// use sscanf::scanf_get_regex;
/// let input = "Test 5 -2";
/// let regex = scanf_get_regex!("Test {usize} {i32}");
/// assert_eq!(regex.as_str(), r"^Test (\+?\d{1,20}) ([-+]?\d{1,10})$");
///
/// let output = regex.captures(input);
/// assert!(output.is_some());
/// let output = output.unwrap();
///
/// let capture_5 = output.get(1);
/// assert!(capture_5.is_some());
/// assert_eq!(capture_5.unwrap().as_str(), "5");
///
/// let capture_negative_2 = output.get(2);
/// assert!(capture_negative_2.is_some());
/// assert_eq!(capture_negative_2.unwrap().as_str(), "-2");
/// ```
pub use sscanf_macro::scanf_get_regex;

/// Same as [`scanf`], but allows use of Regex in the format String.
///
/// Signature and Parameters are the same as [`scanf`].
///
/// ## Examples
/// ```
/// use sscanf::scanf_unescaped;
/// let input = "5.0SOME_RANDOM_TEXT3";
/// let output = scanf_unescaped!(input, "{f32}.*?{usize}"); // .*? matches anything
/// assert_eq!(output.unwrap(), (5.0, 3));
/// ```
///
/// The basic [`scanf`] would escape the `.`, `*` and `?`and match against the literal Characters,
/// as one would expect from a Text matcher:
/// ```
/// use sscanf::scanf;
/// let input = "5.0SOME_RANDOM_TEXT3";
/// let output = scanf!(input, "{f32}.*{usize}");
/// assert!(output.is_err()); // does not match
///
/// let input2 = "5.0.*3";
/// let output2 = scanf!(input2, "{f32}.*{usize}"); // regular scanf is unaffected by special characters
/// assert_eq!(output2.unwrap(), (5.0, 3));
/// ```
///
/// Note that the `{{` and `}}` escaping for literal `{` and `}` is still required.
///
/// Also note that `^` and `$` are automatically added to the start and end.
pub use sscanf_macro::scanf_unescaped;

pub use sscanf_macro::FromScanf;

mod regex_representation;
pub use regex_representation::*;

mod from_scanf;
pub use from_scanf::*;

mod types;
pub use types::*;

mod error;
pub use error::*;

#[doc(hidden)]
pub use const_format;
#[doc(hidden)]
pub use lazy_static;
#[doc(hidden)]
pub use regex;

#[allow(unused_imports)]
use std::str::FromStr; // for links in the documentation
